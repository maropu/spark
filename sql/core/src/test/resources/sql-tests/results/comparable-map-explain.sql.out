-- Automatically generated by SQLQueryTestSuite
-- Number of queries: 10


-- !query
CREATE TEMPORARY VIEW t1 AS SELECT * FROM VALUES
  (map(1, 'a', 2, 'b'), map(2, 'b', 1, 'a')),
  (map(2, 'b', 1, 'a'), map(2, 'b', 1, 'A')),
  (map(3, 'c', 1, 'a'), map(4, 'd', 3, 'c')),
  (map(3, 'c', 1, 'a'), map(3, 'c')),
  (map(3, 'c'), map(4, 'd', 3, 'c')),
  (map(), map(1, 'a')),
  (map(1, 'a'), map())
AS t(v1, v2)
-- !query schema
struct<>
-- !query output



-- !query
EXPLAIN SELECT * FROM t1 ORDER BY v1 = v2
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
*Sort [(sortmapkeys(v1#x) = sortmapkeys(v2#x)) ASC NULLS FIRST], true, 0
+- Exchange rangepartitioning((sortmapkeys(v1#x) = sortmapkeys(v2#x)) ASC NULLS FIRST, 4), ENSURE_REQUIREMENTS, [id=#x]
   +- LocalTableScan [v1#x, v2#x]


-- !query
EXPLAIN SELECT * FROM t1 WHERE v1 = v2 AND v1 = map_concat(v2, map(1, 'a'))
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
*Filter ((sortmapkeys(v1#x) = sortmapkeys(v2#x)) AND (sortmapkeys(v1#x) = sortmapkeys(map_concat(v2#x, map(keys: [1], values: [a])))))
+- *LocalTableScan [v1#x, v2#x]


-- !query
EXPLAIN SELECT * FROM t1 l, t1 r WHERE l.v1 = r.v2 AND l.v1 = map_concat(r.v2, map(1, 'a'))
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
*BroadcastHashJoin [sortmapkeys(v1#x), sortmapkeys(v1#x)], [sortmapkeys(v2#x), sortmapkeys(map_concat(v2#x, map(keys: [1], values: [a])))], Inner, BuildRight, false
:- *LocalTableScan [v1#x, v2#x]
+- BroadcastExchange HashedRelationBroadcastMode(List(sortmapkeys(input[1, map<int,string>, false]), sortmapkeys(map_concat(input[1, map<int,string>, false], map(keys: [1], values: [a])))),false), [id=#x]
   +- LocalTableScan [v1#x, v2#x]


-- !query
EXPLAIN SELECT v1 = v2, count(1) FROM t1 GROUP BY v1 = v2
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
*HashAggregate(keys=[_groupingexpression#x], functions=[count(1)])
+- Exchange hashpartitioning(_groupingexpression#x, 4), ENSURE_REQUIREMENTS, [id=#x]
   +- *HashAggregate(keys=[_groupingexpression#x], functions=[partial_count(1)])
      +- *Project [(sortmapkeys(v1#x) = sortmapkeys(v2#x)) AS _groupingexpression#x]
         +- *LocalTableScan [v1#x, v2#x]


-- !query
EXPLAIN SELECT v1 = v2, count(1) OVER(PARTITION BY v1 = v2) FROM t1 ORDER BY v1
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
*Project [(v1 = v2)#x, count(1) OVER (PARTITION BY (v1 = v2) ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)#xL]
+- *Sort [sortmapkeys(v1#x) ASC NULLS FIRST], true, 0
   +- Exchange rangepartitioning(sortmapkeys(v1#x) ASC NULLS FIRST, 4), ENSURE_REQUIREMENTS, [id=#x]
      +- *Project [(v1 = v2)#x, count(1) OVER (PARTITION BY (v1 = v2) ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)#xL, v1#x]
         +- Window [count(1) windowspecdefinition(_w0#x, specifiedwindowframe(RowFrame, unboundedpreceding$(), unboundedfollowing$())) AS count(1) OVER (PARTITION BY (v1 = v2) ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)#xL], [_w0#x]
            +- *Sort [_w0#x ASC NULLS FIRST], false, 0
               +- Exchange hashpartitioning(_w0#x, 4), ENSURE_REQUIREMENTS, [id=#x]
                  +- *Project [(sortmapkeys(v1#x) = sortmapkeys(v2#x)) AS (v1 = v2)#x, (sortmapkeys(v1#x) = sortmapkeys(v2#x)) AS _w0#x, v1#x]
                     +- *LocalTableScan [v1#x, v2#x]


-- !query
CREATE TEMPORARY VIEW t9 AS SELECT * FROM VALUES
  (map("a", 0.0D, "b", -0.0D)), (map("b", 0.0D, "a", -0.0D))
AS t(v)
-- !query schema
struct<>
-- !query output



-- !query
EXPLAIN SELECT * FROM t9 l, t9 r WHERE l.v = r.v
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
BroadcastHashJoin [sortmapkeys(knownfloatingpointnormalized(transform_values(sortmapkeys(v#x), lambdafunction(knownfloatingpointnormalized(normalizenanandzero(lambda arg2#x)), lambda arg1#x, lambda arg2#x, false))))], [sortmapkeys(knownfloatingpointnormalized(transform_values(sortmapkeys(v#x), lambdafunction(knownfloatingpointnormalized(normalizenanandzero(lambda arg2#x)), lambda arg1#x, lambda arg2#x, false))))], Inner, BuildRight, false
:- LocalTableScan [v#x]
+- BroadcastExchange HashedRelationBroadcastMode(List(sortmapkeys(knownfloatingpointnormalized(transform_values(sortmapkeys(input[0, map<string,double>, false]), lambdafunction(knownfloatingpointnormalized(normalizenanandzero(lambda arg2#x)), lambda arg1#x, lambda arg2#x, false))))),false), [id=#x]
   +- LocalTableScan [v#x]


-- !query
EXPLAIN SELECT v, count(1) FROM t9 GROUP BY v
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
*HashAggregate(keys=[v#x], functions=[count(1)])
+- Exchange hashpartitioning(v#x, 4), ENSURE_REQUIREMENTS, [id=#x]
   +- HashAggregate(keys=[sortmapkeys(knownfloatingpointnormalized(transform_values(v#x, lambdafunction(knownfloatingpointnormalized(normalizenanandzero(lambda arg2#x)), lambda arg1#x, lambda arg2#x, false)))) AS v#x], functions=[partial_count(1)])
      +- LocalTableScan [v#x]


-- !query
EXPLAIN SELECT v, count(1) OVER(PARTITION BY v) FROM t9 ORDER BY v
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
*Sort [sortmapkeys(v#x) ASC NULLS FIRST], true, 0
+- Exchange rangepartitioning(sortmapkeys(v#x) ASC NULLS FIRST, 4), ENSURE_REQUIREMENTS, [id=#x]
   +- Window [count(1) windowspecdefinition(v#x, specifiedwindowframe(RowFrame, unboundedpreceding$(), unboundedfollowing$())) AS count(1) OVER (PARTITION BY v ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)#xL], [sortmapkeys(knownfloatingpointnormalized(transform_values(sortmapkeys(v#x), lambdafunction(knownfloatingpointnormalized(normalizenanandzero(lambda arg2#x)), lambda arg1#x, lambda arg2#x, false))))]
      +- Sort [sortmapkeys(knownfloatingpointnormalized(transform_values(sortmapkeys(v#x), lambdafunction(knownfloatingpointnormalized(normalizenanandzero(lambda arg2#x)), lambda arg1#x, lambda arg2#x, false)))) ASC NULLS FIRST], false, 0
         +- Exchange hashpartitioning(sortmapkeys(knownfloatingpointnormalized(transform_values(sortmapkeys(v#x), lambdafunction(knownfloatingpointnormalized(normalizenanandzero(lambda arg2#x)), lambda arg1#x, lambda arg2#x, false)))), 4), ENSURE_REQUIREMENTS, [id=#x]
            +- LocalTableScan [v#x]
