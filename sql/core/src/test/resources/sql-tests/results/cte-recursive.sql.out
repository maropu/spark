-- Automatically generated by SQLQueryTestSuite
-- Number of queries: 40


-- !query 0
create temporary view t as select * from values 0, 1, 2 as t(id)
-- !query 0 schema
struct<>
-- !query 0 output



-- !query 1
create temporary view t2 as select * from values 0, 1 as t(id)
-- !query 1 schema
struct<>
-- !query 1 output



-- !query 2
WITH r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 2 schema
struct<>
-- !query 2 output
org.apache.spark.sql.AnalysisException
Table or view not found: r; line 4 pos 24


-- !query 3
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 3 schema
struct<level:int>
-- !query 3 output
0
1
10
2
3
4
5
6
7
8
9


-- !query 4
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT * FROM r
-- !query 4 schema
struct<>
-- !query 4 output
org.apache.spark.SparkException
Recursion level limit 12 reached but running query not finished, try increasing 'spark.sql.cte.recursion.level.limit'


-- !query 5
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT * FROM r LIMIT 10
-- !query 5 schema
struct<>
-- !query 5 output
org.apache.spark.SparkException
Recursion level limit 12 reached but running query not finished, try increasing 'spark.sql.cte.recursion.level.limit'


-- !query 6
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT level, level FROM r LIMIT 10
-- !query 6 schema
struct<>
-- !query 6 output
org.apache.spark.SparkException
Recursion level limit 12 reached but running query not finished, try increasing 'spark.sql.cte.recursion.level.limit'


-- !query 7
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT level, level FROM r ORDER BY level LIMIT 10
-- !query 7 schema
struct<>
-- !query 7 output
org.apache.spark.SparkException
Recursion level limit 12 reached but running query not finished, try increasing 'spark.sql.cte.recursion.level.limit'


-- !query 8
WITH RECURSIVE r(c) AS (
  SELECT 'a'
  UNION ALL
  SELECT c || ' b' FROM r WHERE LENGTH(c) < 10
)
SELECT * FROM r
-- !query 8 schema
struct<c:string>
-- !query 8 output
a
a b
a b b
a b b b
a b b b b
a b b b b b


-- !query 9
WITH RECURSIVE r(level) AS (
  SELECT level + 1 FROM r WHERE level < 10
  UNION ALL
  VALUES (0)
)
SELECT * FROM r
-- !query 9 schema
struct<>
-- !query 9 output
org.apache.spark.sql.AnalysisException
number of recursive references must be 1, but 0;


-- !query 10
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  VALUES (0, 'B')
  UNION ALL
  SELECT level + 1, data || 'C' FROM r WHERE level < 3
)
SELECT * FROM r
-- !query 10 schema
struct<>
-- !query 10 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE r(level, data) AS (\n  VALUES (0, 'A')\n  UNION ALL\n  VALUES (0, 'B')\n  UNION'(line 5, pos 2)

== SQL ==
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  VALUES (0, 'B')
  UNION ALL
--^^^
  SELECT level + 1, data || 'C' FROM r WHERE level < 3
)
SELECT * FROM r


-- !query 11
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  SELECT level + 1, data || 'B' FROM r WHERE level < 2
  UNION ALL
  SELECT level + 1, data || 'C' FROM r WHERE level < 3
)
SELECT * FROM r
-- !query 11 schema
struct<>
-- !query 11 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE r(level, data) AS (\n  VALUES (0, 'A')\n  UNION ALL\n  SELECT level + 1, data || 'B' FROM r WHERE level < 2\n  UNION'(line 5, pos 2)

== SQL ==
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  SELECT level + 1, data || 'B' FROM r WHERE level < 2
  UNION ALL
--^^^
  SELECT level + 1, data || 'C' FROM r WHERE level < 3
)
SELECT * FROM r


-- !query 12
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  VALUES (0, 'B')
  UNION ALL
  SELECT level + 1, data || 'C' FROM r WHERE level < 2
  UNION ALL
  SELECT level + 1, data || 'D' FROM r WHERE level < 3
)
SELECT * FROM r
-- !query 12 schema
struct<>
-- !query 12 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE r(level, data) AS (\n  VALUES (0, 'A')\n  UNION ALL\n  VALUES (0, 'B')\n  UNION'(line 5, pos 2)

== SQL ==
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  VALUES (0, 'B')
  UNION ALL
--^^^
  SELECT level + 1, data || 'C' FROM r WHERE level < 2
  UNION ALL
  SELECT level + 1, data || 'D' FROM r WHERE level < 3
)
SELECT * FROM r


-- !query 13
WITH RECURSIVE r(level) AS (
  SELECT level + 1 FROM r WHERE level < 3
)
SELECT * FROM r
-- !query 13 schema
struct<>
-- !query 13 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE r(level) AS (\n  SELECT level + 1 FROM r WHERE level < 3\n)'(line 3, pos 0)

== SQL ==
WITH RECURSIVE r(level) AS (
  SELECT level + 1 FROM r WHERE level < 3
)
^^^
SELECT * FROM r


-- !query 14
WITH RECURSIVE r(level) AS (
  VALUES (0), (0)
  UNION
  SELECT (level + 1) % 10 FROM r
)
SELECT * FROM r
-- !query 14 schema
struct<level:int>
-- !query 14 output
0
1
2
3
4
5
6
7
8
9


-- !query 15
WITH RECURSIVE r(level) AS (
  VALUES (0)
  INTERSECT
  SELECT level + 1 FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 15 schema
struct<>
-- !query 15 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE r(level) AS (\n  VALUES (0)\n  INTERSECT'(line 3, pos 2)

== SQL ==
WITH RECURSIVE r(level) AS (
  VALUES (0)
  INTERSECT
--^^^
  SELECT level + 1 FROM r WHERE level < 10
)
SELECT * FROM r


-- !query 16
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r WHERE (SELECT SUM(level) FROM r) < 10
)
SELECT * FROM r
-- !query 16 schema
struct<>
-- !query 16 output
org.apache.spark.sql.AnalysisException
Table or view not found: r; line 4 pos 56


-- !query 17
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  SELECT r1.level + 1, r1.data
  FROM r AS r1
  JOIN r AS r2 ON r2.data = r1.data
  WHERE r1.level < 10
)
SELECT * FROM r
-- !query 17 schema
struct<>
-- !query 17 output
org.apache.spark.sql.AnalysisException
number of recursive references must be 1, but 2;


-- !query 18
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  SELECT level + 1, r.data
  FROM (
    SELECT 'B' AS data
  ) AS o
  LEFT JOIN r ON r.data = o.data
)
SELECT * FROM r
-- !query 18 schema
struct<>
-- !query 18 output
org.apache.spark.sql.AnalysisException
Detected implicit cartesian product for LEFT OUTER join between logical plans
OneRowRelation
and
Project [col1#x AS level#x, col2#x AS data#x]
+- Filter (col2#x = B)
   +- RecursiveReferences [col1#x,col2#x]
Join condition is missing or trivial.
Either: use the CROSS JOIN syntax to allow cartesian products between these
relations, or: enable implicit cartesian products by setting the configuration
variable spark.sql.crossJoin.enabled=true;


-- !query 19
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  RIGHT JOIN (
    SELECT 'B' AS data
  ) AS o ON o.data = r.data
)
SELECT * FROM r
-- !query 19 schema
struct<>
-- !query 19 output
org.apache.spark.sql.AnalysisException
Detected implicit cartesian product for RIGHT OUTER join between logical plans
Project [col1#x AS level#x, col2#x AS data#x]
+- Filter (B = col2#x)
   +- RecursiveReferences [col1#x,col2#x]
and
OneRowRelation
Join condition is missing or trivial.
Either: use the CROSS JOIN syntax to allow cartesian products between these
relations, or: enable implicit cartesian products by setting the configuration
variable spark.sql.crossJoin.enabled=true;


-- !query 20
WITH RECURSIVE r(level, data) AS (
  SELECT MAX(level) AS level, SUM(data) AS data FROM VALUES (0, 1), (0, 2)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r ORDER BY level
-- !query 20 schema
struct<>
-- !query 20 output
org.apache.spark.sql.AnalysisException
cannot resolve '`level`' given input columns: [col1, col2]; line 2 pos 13


-- !query 21
WITH RECURSIVE r(group, data) AS (
  VALUES (0, 1L)
  UNION ALL
  SELECT 1, SUM(data) FROM r WHERE data < 10 GROUP BY group
)
SELECT * FROM r
-- !query 21 schema
struct<>
-- !query 21 output
org.apache.spark.SparkException
Recursion level limit 12 reached but running query not finished, try increasing 'spark.sql.cte.recursion.level.limit'


-- !query 22
WITH RECURSIVE r(level) AS (
  VALUES (1L)
  UNION ALL
  SELECT SUM(level) FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 22 schema
struct<>
-- !query 22 output
org.apache.spark.SparkException
Recursion level limit 12 reached but running query not finished, try increasing 'spark.sql.cte.recursion.level.limit'


-- !query 23
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT COUNT(*) FROM r
-- !query 23 schema
struct<count(1):bigint>
-- !query 23 output
11


-- !query 24
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  SELECT DISTINCT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 24 schema
struct<level:int,data:string>
-- !query 24 output
0	A
1	A
10	A
2	A
3	A
4	A
5	A
6	A
7	A
8	A
9	A


-- !query 25
WITH RECURSIVE y AS (
  VALUES (1) AS t(id)
),
x AS (
  SELECT * FROM y
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
)
SELECT * FROM x
-- !query 25 schema
struct<>
-- !query 25 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE y AS (\n  VALUES (1) AS t(id)\n)'(line 3, pos 0)

== SQL ==
WITH RECURSIVE y AS (
  VALUES (1) AS t(id)
),
^^^
x AS (
  SELECT * FROM y
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
)
SELECT * FROM x


-- !query 26
WITH RECURSIVE x AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
),
y AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM y WHERE id < 10
)
SELECT * FROM y LEFT JOIN x ON x.id = y.id
-- !query 26 schema
struct<>
-- !query 26 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE x AS (\n  VALUES (1) AS t(id)\n  UNION ALL\n  SELECT id + 1 FROM x WHERE id < 5\n),'(line 5, pos 1)

== SQL ==
WITH RECURSIVE x AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
),
-^^^
y AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM y WHERE id < 10
)
SELECT * FROM y LEFT JOIN x ON x.id = y.id


-- !query 27
WITH RECURSIVE x AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
),
y AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 10
)
SELECT * FROM y LEFT JOIN x ON x.id = y.id
-- !query 27 schema
struct<>
-- !query 27 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE x AS (\n  VALUES (1) AS t(id)\n  UNION ALL\n  SELECT id + 1 FROM x WHERE id < 5\n),'(line 5, pos 1)

== SQL ==
WITH RECURSIVE x AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
),
-^^^
y AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 10
)
SELECT * FROM y LEFT JOIN x ON x.id = y.id


-- !query 28
WITH RECURSIVE x AS (
  SELECT 1 AS id
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 3
),
y AS (
  SELECT * FROM x
  UNION ALL
  SELECT * FROM x
),
z AS (
  SELECT * FROM x
  UNION ALL
  SELECT id + 1 FROM z WHERE id < 10
)
SELECT * FROM z
-- !query 28 schema
struct<>
-- !query 28 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE x AS (\n  SELECT 1 AS id\n  UNION ALL\n  SELECT id + 1 FROM x WHERE id < 3\n),'(line 5, pos 1)

== SQL ==
WITH RECURSIVE x AS (
  SELECT 1 AS id
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 3
),
-^^^
y AS (
  SELECT * FROM x
  UNION ALL
  SELECT * FROM x
),
z AS (
  SELECT * FROM x
  UNION ALL
  SELECT id + 1 FROM z WHERE id < 10
)
SELECT * FROM z


-- !query 29
WITH RECURSIVE x AS (
  SELECT 1 AS id
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 3
),
y AS (
  SELECT * FROM x
  UNION ALL
  SELECT * FROM x
),
z AS (
  SELECT * FROM y
  UNION ALL
  SELECT id + 1 FROM z WHERE id < 10
)
SELECT * FROM z
-- !query 29 schema
struct<>
-- !query 29 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE x AS (\n  SELECT 1 AS id\n  UNION ALL\n  SELECT id + 1 FROM x WHERE id < 3\n),'(line 5, pos 1)

== SQL ==
WITH RECURSIVE x AS (
  SELECT 1 AS id
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 3
),
-^^^
y AS (
  SELECT * FROM x
  UNION ALL
  SELECT * FROM x
),
z AS (
  SELECT * FROM y
  UNION ALL
  SELECT id + 1 FROM z WHERE id < 10
)
SELECT * FROM z


-- !query 30
WITH t AS (
  WITH RECURSIVE s AS (
    VALUES (1) AS t(i)
    UNION ALL
    SELECT i + 1 FROM s
  )
  SELECT i AS j FROM s LIMIT 10
)
SELECT * FROM t
-- !query 30 schema
struct<>
-- !query 30 output
java.lang.NullPointerException
null


-- !query 31
WITH RECURSIVE outermost AS (
  WITH innermost AS (
    SELECT * FROM outermost
  )
  SELECT level + 1 FROM innermost WHERE level < 5
  UNION ALL
  SELECT 0 AS level
)
SELECT * FROM outermost
-- !query 31 schema
struct<>
-- !query 31 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE outermost AS (\n  WITH'(line 2, pos 2)

== SQL ==
WITH RECURSIVE outermost AS (
  WITH innermost AS (
--^^^
    SELECT * FROM outermost
  )
  SELECT level + 1 FROM innermost WHERE level < 5
  UNION ALL
  SELECT 0 AS level
)
SELECT * FROM outermost


-- !query 32
WITH RECURSIVE t AS (
  WITH RECURSIVE s AS (
    VALUES (1) AS t(i)
    UNION ALL
    SELECT i + 1 FROM s WHERE i < 10
  )
  SELECT i AS j FROM s
  UNION ALL
  SELECT j + 1 FROM t WHERE j < 10
)
SELECT * FROM t
-- !query 32 schema
struct<>
-- !query 32 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE t AS (\n  WITH'(line 2, pos 2)

== SQL ==
WITH RECURSIVE t AS (
  WITH RECURSIVE s AS (
--^^^
    VALUES (1) AS t(i)
    UNION ALL
    SELECT i + 1 FROM s WHERE i < 10
  )
  SELECT i AS j FROM s
  UNION ALL
  SELECT j + 1 FROM t WHERE j < 10
)
SELECT * FROM t


-- !query 33
WITH RECURSIVE t AS (
  WITH RECURSIVE s AS (
    SELECT j, 1 AS i FROM t
    UNION ALL
    SELECT j, i + 1 FROM s WHERE i < 3
  )
  VALUES (1) as t(j)
  UNION ALL
  SELECT j + 1 FROM s WHERE j < 3
)
SELECT * FROM t
-- !query 33 schema
struct<>
-- !query 33 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE t AS (\n  WITH'(line 2, pos 2)

== SQL ==
WITH RECURSIVE t AS (
  WITH RECURSIVE s AS (
--^^^
    SELECT j, 1 AS i FROM t
    UNION ALL
    SELECT j, i + 1 FROM s WHERE i < 3
  )
  VALUES (1) as t(j)
  UNION ALL
  SELECT j + 1 FROM s WHERE j < 3
)
SELECT * FROM t


-- !query 34
CREATE TEMPORARY VIEW routes(origin, destination) AS VALUES
  ('New York', 'Washington'),
  ('New York', 'Boston'),
  ('Boston', 'New York'),
  ('Washington', 'Boston'),
  ('Washington', 'Raleigh')
-- !query 34 schema
struct<>
-- !query 34 output



-- !query 35
WITH RECURSIVE destinations_from_new_york AS (
  SELECT 'New York' AS destination, ARRAY('New York') AS path, 0 AS length
  UNION ALL
  SELECT r.destination, CONCAT(d.path, ARRAY(r.destination)), d.length + 1
  FROM routes AS r
  JOIN destinations_from_new_york AS d ON d.destination = r.origin AND NOT ARRAY_CONTAINS(d.path, r.destination)
)
SELECT * FROM destinations_from_new_york
-- !query 35 schema
struct<>
-- !query 35 output
java.lang.NullPointerException
null


-- !query 36
WITH RECURSIVE fibonacci AS (
  VALUES (0, 1) AS t(a, b)
  UNION ALL
  SELECT b, a + b FROM fibonacci WHERE a < 10
)
SELECT a FROM fibonacci ORDER BY a
-- !query 36 schema
struct<>
-- !query 36 output
java.lang.NullPointerException
null


-- !query 37
DROP VIEW IF EXISTS t
-- !query 37 schema
struct<>
-- !query 37 output



-- !query 38
DROP VIEW IF EXISTS t2
-- !query 38 schema
struct<>
-- !query 38 output



-- !query 39
DROP VIEW IF EXISTS routes
-- !query 39 schema
struct<>
-- !query 39 output

